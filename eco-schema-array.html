<link rel="import" href="../polymer/polymer.html"/>
<link rel="import" href="../iron-flex-layout/iron-flex-layout.html"/>

<dom-module id="eco-schema-array">

  <link rel="import" href="../iron-icons/iron-icons.html"/>
  <link rel="import" href="../paper-icon-button/paper-icon-button.html"/>
  <link rel="import" href="../paper-input/paper-input.html"/>

  <link rel="import" href="./eco-schema-object.html"/>

  <template>

    <style>

      :host {
        display: block;
      }

    </style>

    <div class="vertical layout">

      <div class="horizontal center layout">
        <div class="flex header" hidden$="[[!label]]">[[label]]</div>
        <paper-icon-button icon="add" on-click="_onAddItem"></paper-icon-button>
      </div>

      <div id="form"></div>

    </div>

  </template>

  <script>
    Polymer({
      is: 'eco-schema-array',
      properties: {
        schema: {
          type: Object,
          observer: '_schemaChanged'
        },
        label: {
          type: String
        },
        value: {
          type: Object,
          notify: true,
          value: function() { return []; }
        }
      },
      observers: [
        '_schemaArraySplicesChanged(_schemaArrayItems.splices)'
      ],
      ready: function() {

      },
      _buildSchemaArrayItems: function(schema) {
        if (this.value && this.value.length) {
          return this.value.map(function(item) {
            return {
              label: schema.items.title,
              type: schema.items.type,
              schema: schema.items,
              value: item
            };
          });
        } else {
          return [];
        }
      },
      _schemaArraySplicesChanged: function(detail) {

        if (!detail) {
          return console.error('detail is undefined');
        }

        var ctx = this;

        if (detail.keySplices) {
          console.error('Got keySplices, don\'t know what to do with them!');
        }

        detail.indexSplices.forEach(function(splice) {
          var args = ['value', splice.index, splice.removed.length];

          if (splice.removed && splice.removed.length) {
            for (var i = splice.index, ii = splice.index + splice.removed.length; i < ii; i++) {
              var el = ctx.$.form.children[i];
              ctx.unlisten(el, 'value-changed', '_schemaArrayItemChanged');
              ctx.$.form.removeChild(el);
            }
          }

          if (splice.addedCount) {
            for (var i = splice.index, ii = splice.index + splice.addedCount; i < ii; i++) {
              var item = splice.object[i];

              var el = ctx.create(item.component, item.properties);
              var beforeEl = ctx.$.form.children[i];

              el.schemaArrayItem = item;

              if (beforeEl) {
                Polymer.dom(ctx.$.form).insertBefore(el, beforeEl);
              } else {
                Polymer.dom(ctx.$.form).appendChild(el);
              }

              if (item.schema) {
                el.schema = item.schema;
              }

              ctx.listen(el, 'value-changed', '_schemaArrayItemChanged');

              args.push(el.value);
            }
          }
          ctx.splice.apply(ctx, args);
        });

        console.groupEnd();
      },
      _schemaArrayItemChanged: function(event, detail) {

        if (detail.path && /\.length$/.test(detail.path)) {
          return;
        }

        var ctx = this;
        var item = event.target.schemaArrayItem;
        var index = this._schemaArrayItems.indexOf(item);
        var path = ['value', index];

        if (detail.path && /\.splices$/.test(detail.path)) {
          path = path.concat(detail.path.split('.').slice(1, -1));

          if (detail.value.keySplices) {
            console.warn('Got keySplices, don\'t know what to do with them!');
          }

          detail.value.indexSplices.forEach(function (splice) {
            var args = [path.join('.'), splice.index, splice.removed.length];

            if (splice.addedCount) {
              for (var i = splice.index, ii = splice.index + splice.addedCount; i < ii; i++) {
                ctx.set(path.concat([i]), splice.object[i])
              }
            }
          });
        } else if (detail.path) {
          var path = path.concat(detail.path.split('.').slice(1));
          this.set(path, detail.value);
        } else {
          this.set(path, detail.value);
        }
      },
      _schemaChanged: function() {
        this._schemaArrayItems = this._buildSchemaArrayItems(this.schema);
      },
      _onAddItem: function() {
        var schema = this.schema.items;
        var item = {
          properties: {
            label: schema.title
          },
          schema: schema
        };

        if (schema.component) {
          item.component = schema.component;
        } else if (this._isSchemaValue(schema.type)) {
          item.component = 'paper-input';
        } else if (this._isSchemaObject(schema.type)) {
          item.component = 'eco-schema-object';
        } else if (this._isSchemaArray(schema.type)) {
          item.component = 'eco-schema-array';
        }

        this.push('_schemaArrayItems', item);
      },
      _onRemoveItem: function(e) {
        this._schemaArrayItems = this._schemaArrayItems.filter(function(item) {
          return item !== e.model.item;
        });
      },
      _isSchemaValue: function(type) {
        if (Array.isArray(type)) {
          return type.indexOf('string') !== -1 || type.indexOf('number') !== -1 || type.indexOf('boolean') !== -1;
        } else {
          return type === 'string' || type === 'number' || type === 'boolean';
        }
      },
      _isSchemaObject: function(type) {
        return type === 'object';
      },
      _isSchemaArray: function(type) {
        return type === 'array';
      }
    });
  </script>

</dom-module>
